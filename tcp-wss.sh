#!/bin/sh
# 论坛链接: https://1024.day
# 脚本名称: tcp-wss.sh
# 脚本功能: 提供菜单选项安装不同类型的代理服务
# 创建日期: 2025年4月13日
# 支持系统: Debian, Ubuntu, CentOS 7及以上
# 特点: 一键安装多种代理服务，包括Shadowsocks、V2Ray+WSS、Reality和Hysteria2

# 引入共享库，并设置错误处理
. ./common.sh || { echo "Error: common.sh not found or failed to source."; exit 1; }

# 执行初始化检查
check_root
# 设置系统时区
set_timezone

# 设置通用参数 (在需要时生成)
v2path=""
v2uuid=""
# ssport=$(gen_port) # ssport 在 common.sh 中已定义，但这里不需要提前生成

# 安装前检查函数 (用于V2ray+WSS安装)
install_precheck(){
    echo "==== Enter the domain name already configured with DNS ===="
    read -p "Domain Name: " domain
    if [ -z "$domain" ]; then
        error_exit "Domain name cannot be empty."
    fi
    # 简单的域名格式检查 (不完全严格)
    if ! echo "$domain" | grep -qE '^[a-zA-Z0-9.-]+$'; then
         error_exit "Invalid domain name format."
    fi

    # 交互式设置端口
    local getPort=443 # Default port
    read -t 15 -p "Enter port number (1-65535) [Default: 443, wait 15s]: " inputPort
    if [ -n "$inputPort" ]; then
        if ! echo "$inputPort" | grep -qE '^[0-9]+$'; then
            error_exit "Invalid port number entered. Please enter numbers only."
        fi
        if [ "$inputPort" -lt 1 ] || [ "$inputPort" -gt 65535 ]; then
            error_exit "Port number out of range (1-65535)."
        fi
        getPort=$inputPort
        echo "Using custom port: $getPort"
    else
        echo "Using default port: 443"
    fi
    # 将端口号导出为全局变量，供后续函数使用
    export WSS_PORT=$getPort
    export WSS_DOMAIN=$domain

    # 安装基本工具
    install_base
    # 安装网络工具包，用于检查端口占用
    echo "Installing net-tools for port checking..."
    install_debian_tools "net-tools"
    install_centos_tools "net-tools"

    # 等待3秒，确保系统稳定
    echo "Checking for port conflicts on 80 and 443..."
    sleep 3
    # 检查80和443端口是否被占用 (更精确的检查)
    if netstat -tuln | grep -qE ':(80|443)\s'; then
        local isPort=$(netstat -tulnp | grep -E ':(80|443)\s')
        clear
        echo "=================================================="
        echo " Error: Port 80 or 443 is already in use."
        echo " Please stop the conflicting service before running this script."
        echo
        echo " Port usage details:"
        echo "$isPort"
        echo "=================================================="
        exit 1
    else
        echo "Ports 80 and 443 are available."
    fi
}

# 安装和配置Nginx的函数
install_nginx(){
    # 从环境变量获取端口和域名
    local domain=${WSS_DOMAIN:?} # 使用 :? 确保变量已设置
    local getPort=${WSS_PORT:?}

    # 生成 v2path (如果尚未生成)
    if [ -z "$v2path" ]; then
        echo "Generating WebSocket path..."
        v2path=$(gen_path)
        echo "WebSocket path: /$v2path"
    fi
    export V2_WSPATH=$v2path # 导出供后续使用

    echo "Installing Nginx, cron, socat..."
    # 根据系统类型安装Nginx和其他必要组件
    install_debian_tools "nginx cron socat"
    install_centos_tools "nginx cronie socat"

    echo "Creating Nginx configuration file..."
# 创建Nginx配置文件
cat >/etc/nginx/nginx.conf<<EOF || error_exit "Failed to write Nginx config file."
# Nginx config generated by tcp-wss.sh
user www-data; # Or nginx on CentOS
pid /var/run/nginx.pid;
worker_processes auto;
worker_rlimit_nofile 51200;

events {
    worker_connections 4096; # Adjusted from 1024
    multi_accept on;
    use epoll;
}

http {
    # Basic Settings
    server_tokens off;
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 120s;
    keepalive_requests 10000;
    client_max_body_size 20m; # Allow larger file uploads if needed
    types_hash_max_size 2048;
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    # Logging (disabled access log, errors to /dev/null)
    access_log off;
    error_log /dev/null; # Consider logging errors to a file for debugging

    # Gzip Settings (optional)
    # gzip on;
    # gzip_vary on;
    # gzip_proxied any;
    # gzip_comp_level 6;
    # gzip_buffers 16 8k;
    # gzip_http_version 1.1;
    # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;

    # HTTP Server (Redirects to HTTPS)
    server {
        listen 80;
        listen [::]:80;
        server_name $domain;
        # For ACME challenge
        location ~ /.well-known/acme-challenge/ {
          allow all;
          root /var/www/html; # Default web root, adjust if needed
        }
        location / {
            return 301 https://\$host\$request_uri;
        }
    }

    # HTTPS Server (Main V2Ray Proxy)
    server {
        listen $getPort ssl http2;
        listen [::]:$getPort ssl http2;
        server_name $domain;

        # SSL Settings (Paths provided by acme.sh post-hook)
        ssl_certificate /etc/letsencrypt/live/$domain/fullchain.pem;
        ssl_certificate_key /etc/letsencrypt/live/$domain/privkey.pem;
        ssl_protocols TLSv1.2 TLSv1.3; # Modern protocols
        ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
        ssl_prefer_server_ciphers off; # Client chooses best cipher
        ssl_session_cache shared:SSL:10m; # Enable session cache
        ssl_session_timeout 1d;
        ssl_session_tickets off; # Disable session tickets for better security (optional)
        # ssl_stapling on; # Enable OCSP Stapling (Requires resolver)
        # ssl_stapling_verify on;
        # resolver 8.8.8.8 8.8.4.4 valid=300s; # Example resolver
        # resolver_timeout 5s;

        # Security Headers (Optional but Recommended)
        # add_header Strict-Transport-Security "max-age=63072000; includeSubDomains; preload" always;
        # add_header X-Frame-Options DENY always;
        # add_header X-Content-Type-Options nosniff always;
        # add_header X-XSS-Protection "1; mode=block" always;
        # add_header Referrer-Policy "no-referrer-when-downgrade" always;
        # add_header Content-Security-Policy "default-src 'self'; script-src 'self'; object-src 'none'; frame-ancestors 'none'; upgrade-insecure-requests;" always;

        # Default root location (optional placeholder page)
        location / {
            root /var/www/html; # Match ACME challenge root or change as needed
            index index.html index.htm;
            # Or return a simple message:
            # default_type text/plain;
            # return 200 "Hello from Nginx!";
        }

        # V2Ray WebSocket Location
        location /$v2path {
            if (\$http_upgrade != "websocket") { # Block non-websocket requests
                return 404;
            }
            proxy_redirect off;
            proxy_pass http://127.0.0.1:8080; # V2Ray listens on this port (defined in V2Ray config)
            proxy_http_version 1.1;
            proxy_set_header Upgrade \$http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host \$host; # Pass the original host header
            # Mitigate proxy buffering issues
            proxy_buffering off;
            # Increase proxy timeouts for long connections
            proxy_read_timeout 300s;
            proxy_send_timeout 300s;
            # Pass real client IP (optional, V2Ray needs to be configured to use it)
            # proxy_set_header X-Real-IP \$remote_addr;
            # proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        }
    }
}
EOF
    # 检查 Nginx 配置语法
    echo "Checking Nginx configuration syntax..."
    nginx -t || error_exit "Nginx configuration test failed. Please check /etc/nginx/nginx.conf."
    echo "Nginx configuration file created and syntax check passed."
}

# 获取SSL证书的函数
acme_ssl(){
    local domain=${WSS_DOMAIN:?}
    local acme_sh_path="$HOME/.acme.sh/acme.sh" # Default path

    # 检查 Nginx 是否在运行，acme standalone 需要停止它
    if systemctl is-active --quiet nginx; then
        echo "Stopping Nginx for ACME standalone challenge..."
        systemctl stop nginx || error_exit "Failed to stop Nginx."
    fi
    # 确保端口 80 可用
    if netstat -tuln | grep -qE ':80\s'; then
        error_exit "Port 80 is still in use after stopping Nginx. Cannot run ACME standalone challenge."
    fi
    
    echo "Installing/Updating acme.sh script..."
    # 使用安全函数下载并执行 acme.sh 安装脚本
    # 传递 email 参数 (acme.sh 会读取环境变量 ACME_EMAIL)
    export ACME_EMAIL="my@example.com" # 使用一个占位符，或者让用户输入
    read -p "Enter email address for Let's Encrypt notifications [Default: my@example.com]: " user_email
    if [ -n "$user_email" ]; then
        export ACME_EMAIL="$user_email"
    fi
    echo "Using email: $ACME_EMAIL"

    safe_run_remote_script "https://get.acme.sh" "acme.sh"

    # 检查 acme.sh 是否安装成功
    if [ ! -f "$acme_sh_path" ]; then
        # 尝试在 root 的 home 目录查找
        acme_sh_path="/root/.acme.sh/acme.sh"
        if [ ! -f "$acme_sh_path" ]; then
            error_exit "acme.sh installation failed or not found at expected paths."
        fi
    fi
    echo "acme.sh script found at $acme_sh_path"

    echo "Issuing SSL certificate for $domain using ECC key..."
    # 创建证书存储目录 (acme.sh 通常会自己创建，但先创建无害)
    mkdir -p /etc/letsencrypt/live/$domain || error_exit "Failed to create directory /etc/letsencrypt/live/$domain"

    # 使用 standalone 模式申请证书
    # 注意: --reloadcmd 在 standalone 模式下可能不如 --post-hook 配合 --webroot 可靠
    # 改为使用 post-hook 安装证书，然后手动启动 Nginx
    "$acme_sh_path" --issue -d "$domain" --standalone --keylength ec-256 --force || error_exit "Failed to issue SSL certificate using standalone mode."

    echo "Installing certificate..."
    "$acme_sh_path" --installcert -d "$domain" --ecc \
        --fullchain-file /etc/letsencrypt/live/$domain/fullchain.pem \
        --key-file /etc/letsencrypt/live/$domain/privkey.pem \
        || error_exit "Failed to install certificate using acme.sh."
    
    # 重新启动 Nginx
    echo "Starting Nginx..."
    systemctl start nginx || error_exit "Failed to start Nginx after certificate installation."
    
    # 添加 cron 任务进行自动续期
    echo "Setting up automatic certificate renewal..."
    # acme.sh 安装时通常会自动添加 cron 任务，这里可以检查或强制添加
    "$acme_sh_path" --cron --home "$HOME/.acme.sh" || echo "Warning: Failed to ensure acme.sh cron job is set up." >&2
    
    echo "SSL certificate obtained and installed successfully."
}

# 安装V2Ray的函数
install_v2ray(){
    local domain=${WSS_DOMAIN:?}
    local getPort=${WSS_PORT:?}
    local v2path=${V2_WSPATH:?}

    # 生成 V2Ray UUID (如果尚未生成)
    if [ -z "$v2uuid" ]; then
        echo "Generating V2Ray UUID..."
        v2uuid=$(gen_uuid)
        echo "V2Ray UUID: $v2uuid"
    fi
    export V2_UUID=$v2uuid # 导出供后续使用
    
    echo "Installing V2Ray..."
    # 使用安全函数执行官方脚本安装 V2Ray
    safe_run_remote_script "https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh" "V2Ray"

    # 检查 V2Ray 是否安装成功
    command -v /usr/local/bin/v2ray > /dev/null || error_exit "V2Ray installation failed or '/usr/local/bin/v2ray' not found."
    
    echo "Creating V2Ray configuration file..."
# 创建V2Ray配置文件
cat >/usr/local/etc/v2ray/config.json<<EOF || error_exit "Failed to write V2Ray config file."
{
  "log": {
    "loglevel": "warning"
  },
  "inbounds": [
    {
      "listen": "127.0.0.1",  # 只监听本地回环地址
      "port": 8080,          # Nginx 将流量转发到此端口
      "protocol": "vmess",
      "settings": {
        "clients": [
          {
            "id": "$v2uuid",
            "alterId": 0 # Vmess recommends alterId=0 now
          }
        ],
        "disableInsecureEncryption": false # Be aware of security implications if changed
      },
      "streamSettings": {
        "network": "ws",
        "wsSettings": {
          "path": "/$v2path" # 与 Nginx 配置中的路径一致
        }
      },
      "sniffing": {
        "enabled": true,
        "destOverride": ["http", "tls"]
      }
    }
  ],
  "outbounds": [
    {
      "protocol": "freedom",
      "settings": {}
    },
    {
      "protocol": "blackhole",
      "settings": {},
      "tag": "blocked"
    }
  ]
  // Optional routing rules
  // "routing": {
  //   "domainStrategy": "AsIs",
  //   "rules": [
  //     {
  //       "type": "field",
  //       "ip": ["geoip:private"],
  //       "outboundTag": "blocked"
  //     },
  //     {
  //       "type": "field",
  //       "protocol": ["bittorrent"],
  //       "outboundTag": "blocked"
  //     }
  //   ]
  // }
}
EOF

    # 启用并启动V2Ray服务，然后重启Nginx确保配置生效
    echo "Enabling and restarting V2Ray service..."
    enable_service v2ray
    echo "Restarting Nginx service..."
    systemctl restart nginx.service || error_exit "Failed to restart Nginx service."
    
    # 清理安装文件 (仅清理此脚本自身)
    # install-release.sh 已经在 safe_run_remote_script 中被清理
    # clean_files tcp-wss.sh # 这个脚本是主入口，不应清理

    echo "Creating V2Ray client configuration file template..."
# 创建客户端配置文件
cat >/usr/local/etc/v2ray/client.json<<EOF || error_exit "Failed to write V2Ray client config file."
{
===========配置参数 (V2RayN/V2RayNG 格式)=============
协议(Protocol)：VMess
地址(Address)：${domain}
端口(Port)：${getPort}
用户ID(UUID)：${v2uuid}
额外ID(AlterID)：0
加密方式(Security)：auto (建议客户端选 aes-128-gcm 或 none，取决于 V2Ray 版本和 disableInsecureEncryption 设置)
传输协议(Network)：ws
伪装类型(Type)：none
伪装域名/主机(Host)：${domain}
路径(Path)：/${v2path}
底层传输安全(TLS)：tls
跳过证书验证(allowInsecure)：false (保持 false 以确保安全)
SNI：${domain}
指纹(Fingerprint)：(可选, 如 chrome)

====================================
(以下是 VLESS 链接示例，如果需要 VMess 链接请参考上方参数)
注意：这个脚本安装的是 VMess，不是 VLESS。下面的链接仅作格式参考。
vless://YOUR_UUID@${domain}:${getPort}?type=ws&security=tls&path=%2F${v2path}&host=${domain}&sni=${domain}#1024-wss

请使用上方参数手动配置您的 V2Ray 客户端。
}
EOF
    echo "Client configuration template saved to /usr/local/etc/v2ray/client.json"

    # 清屏
    clear
}

# 安装Shadowsocks-rust的函数
install_ssrust(){
    echo "Starting Shadowsocks-rust installation..."
    # **MODIFIED:** 直接运行本地的Shadowsocks安装脚本
    bash ./ss-rust.sh || error_exit "Shadowsocks-rust installation script (./ss-rust.sh) failed."
    echo "Shadowsocks-rust installation finished."
}

# 安装Reality代理的函数
install_reality(){
    echo "Starting Reality installation..."
    # **MODIFIED:** 直接运行本地的Reality安装脚本
    bash ./reality.sh || error_exit "Reality installation script (./reality.sh) failed."
    echo "Reality installation finished."
}

# 安装Hysteria2代理的函数
install_hy2(){
    echo "Starting Hysteria2 installation..."
    # **MODIFIED:** 直接运行本地的Hysteria2安装脚本
    bash ./hy2.sh || error_exit "Hysteria2 installation script (./hy2.sh) failed."
    echo "Hysteria2 installation finished."
}

# 输出V2Ray客户端配置信息的函数
client_v2ray(){
    # 从环境变量获取参数
    local domain=${WSS_DOMAIN:?}
    local getPort=${WSS_PORT:?}
    local v2path=${V2_WSPATH:?}
    local v2uuid=${V2_UUID:?}

    # 生成 V2RayN/v2rayNG 兼容的 base64 配置
    local vmess_config="{\"v\":\"2\",\"ps\":\"1024-wss-${domain}\",\"add\":\"${domain}\",\"port\":\"${getPort}\",\"id\":\"${v2uuid}\",\"aid\":\"0\",\"net\":\"ws\",\"type\":\"none\",\"host\":\"${domain}\",\"path\":\"/${v2path}\",\"tls\":\"tls\",\"sni\":\"${domain}\",\"allowInsecure\":false}"
    local wslink=$(echo -n "${vmess_config}" | base64 -w 0) || echo "Warning: Failed to generate base64 VMess link." >&2

    show_completion
    echo "===========V2Ray (VMess+WS+TLS) Configuration============"
    echo "Protocol：VMess"
    echo "Address：${domain}"
    echo "Port：${getPort}"
    echo "UUID：${v2uuid}"
    echo "AlterID：0"
    echo "Security：auto (建议客户端选 aes-128-gcm 或 none)"
    echo "Network：ws"
    echo "Host：${domain}"
    echo "Path：/${v2path}"
    echo "TLS：tls"
    echo "SNI: ${domain}"
    echo "Skip Cert Verify：false"
    echo "======================================================="
    if [[ -n "$wslink" ]]; then
        echo "Client URI (Import this link into V2RayN/V2RayNG etc.):"
        echo "vmess://${wslink}"
    else
        echo "VMess link generation failed. Please configure manually using the parameters above."
    fi
    echo "Client configuration template saved to: /usr/local/etc/v2ray/client.json"
    echo
}

# 显示主菜单的函数
start_menu(){
    clear
    echo " ================================================== "
    echo " Forum：https://1024.day                            "
    echo " Description: One-click installer for SS-Rust, V2Ray+WSS, Reality, Hysteria2 "
    echo " System: Ubuntu, Debian, CentOS                   "
    echo " ================================================== "
    echo
    echo " 1. Install Shadowsocks-rust"
    echo " 2. Install V2Ray + WebSocket + TLS (Requires Domain)"
    echo " 3. Install Reality (No Domain Needed)"
    echo " 4. Install Hysteria2 (No Domain Needed)"
    echo " 0. Exit Script"
    echo
    read -p "Enter selection [0-4]: " num

    case "$num" in
    1)
        install_ssrust
        ;;
    2)
        install_precheck # 获取域名和端口，检查环境
        install_nginx    # 安装配置 Nginx
        acme_ssl         # 获取 SSL 证书
        install_v2ray    # 安装配置 V2Ray
        client_v2ray     # 显示客户端信息
        ;;
    3)
        install_reality
        ;;
    4)
        install_hy2
        ;;
    0)
        echo "Exiting script."
        exit 0
        ;;
    *)
        clear
        echo "Invalid selection. Please enter a number between 0 and 4."
        sleep 2s
        start_menu # 重新显示菜单
        ;;
    esac
}

# 启动主菜单
start_menu

echo "Main script finished."